"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const tslib_1 = require("tslib");
const Debug = require("debug");
const extractor_1 = require("../extractor");
const static_1 = require("../inputs/apk/static");
const static_2 = require("../inputs/apt/static");
const static_3 = require("../inputs/binaries/static");
const static_4 = require("../inputs/distroless/static");
const filePatternStatic = require("../inputs/file-pattern/static");
const static_5 = require("../inputs/node/static");
const static_6 = require("../inputs/os-release/static");
const static_7 = require("../inputs/rpm/static");
const types_1 = require("../types");
const applications_1 = require("./applications");
const osReleaseDetector = require("./os-release");
const apk_1 = require("./package-managers/apk");
const apt_1 = require("./package-managers/apt");
const rpm_1 = require("./package-managers/rpm");
const debug = Debug("snyk");
function analyze(targetImage, dockerfileAnalysis, options) {
    return tslib_1.__awaiter(this, void 0, void 0, function* () {
        if (options.imageType !== types_1.ImageType.DockerArchive) {
            throw new Error("Unhandled image type");
        }
        const staticAnalysisActions = [
            static_1.getApkDbFileContentAction,
            static_2.getDpkgFileContentAction,
            static_2.getExtFileContentAction,
            static_7.getRpmDbFileContentAction,
            ...static_6.getOsReleaseActions,
            static_3.getNodeBinariesFileContentAction,
            static_3.getOpenJDKBinariesFileContentAction,
            static_5.getNodeAppFileContentAction,
        ];
        if (options.distroless) {
            staticAnalysisActions.push(static_4.getDpkgPackageFileContentAction);
        }
        const checkForGlobs = shouldCheckForGlobs(options);
        if (checkForGlobs) {
            staticAnalysisActions.push(filePatternStatic.generateExtractAction(options.globsToFind.include, options.globsToFind.exclude));
        }
        const dockerArchive = yield extractor_1.getDockerArchiveLayersAndManifest(options.imagePath, staticAnalysisActions);
        const archiveLayers = dockerArchive.layers;
        const [apkDbFileContent, aptDbFileContent, rpmDbFileContent,] = yield Promise.all([
            static_1.getApkDbFileContent(archiveLayers),
            static_2.getAptDbFileContent(archiveLayers),
            static_7.getRpmDbFileContent(archiveLayers),
        ]);
        let distrolessAptFiles = [];
        if (options.distroless) {
            distrolessAptFiles = static_4.getAptFiles(archiveLayers);
        }
        const manifestFiles = [];
        if (checkForGlobs) {
            const matchingFiles = filePatternStatic.getMatchingFiles(archiveLayers);
            manifestFiles.push(...matchingFiles);
        }
        let osRelease;
        try {
            osRelease = yield osReleaseDetector.detectStatically(archiveLayers, dockerfileAnalysis);
        }
        catch (err) {
            debug(err);
            throw new Error("Failed to detect OS release");
        }
        let results;
        try {
            results = yield Promise.all([
                apk_1.analyze(targetImage, apkDbFileContent),
                apt_1.analyze(targetImage, aptDbFileContent),
                rpm_1.analyze(targetImage, rpmDbFileContent),
                apt_1.analyzeDistroless(targetImage, distrolessAptFiles),
            ]);
        }
        catch (err) {
            debug(err);
            throw new Error("Failed to detect installed OS packages");
        }
        const imageId = imageIdFromArchiveManifest(dockerArchive.manifest);
        const binaries = static_3.getBinariesHashes(archiveLayers);
        const applicationDependenciesScanResults = [];
        const nodeDependenciesScanResults = yield applications_1.nodeFilesToScannedProjects(static_5.getNodeAppFileContent(archiveLayers));
        applicationDependenciesScanResults.push(...nodeDependenciesScanResults);
        return {
            imageId,
            osRelease,
            results,
            binaries,
            imageLayers: dockerArchive.manifest.Layers,
            applicationDependenciesScanResults,
            manifestFiles,
        };
    });
}
exports.analyze = analyze;
function imageIdFromArchiveManifest(manifest) {
    try {
        return manifest.Config.split(".")[0];
    }
    catch (err) {
        debug(manifest);
        debug(err);
        throw new Error("Failed to extract image ID from archive manifest");
    }
}
function shouldCheckForGlobs(options) {
    return (options &&
        options.globsToFind &&
        options.globsToFind.include &&
        Array.isArray(options.globsToFind.include) &&
        options.globsToFind.include.length > 0);
}
//# sourceMappingURL=static-analyzer.js.map